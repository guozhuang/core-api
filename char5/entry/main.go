package main

//golang并发相关的思考

//1.并发相关
//并发是指一段时间内的多个任务的运行，只是外部看来似乎是'同时'完成的，使得系统的运行效率提升【并发设计更加偏向于过程性】
//所以并发模型的设计是整个系统中比较攸关性能体验的点【同时也是系统设计中的逻辑层】【并且考虑到现在硬件性能提升上的瓶颈，多核对并发上更常见】
//golang在并发编程中，语言原生就极大地支持了并发编程
//go，chan（以及chan的操作符），select

//并发设计从最早期os的分时系统【本质上也是并发的支持】，到多任务【进程】并发调度，再到进程中创建用户态线程来自己实现线程调度（相应难度比较大）
//golang通过MPG模型，通过内核态线程绑定M结构，通过M绑定对应的P（相应的goroutine执行环境），以及P下面挂在goroutine队列
//实现对goroutine的调度【并发调度：体现出了goroutine创建以及执行的无序性，以及检查机制】
//MPG模型也是为何设置GOMAXPROCS来设置整体并发度的体现

//2.goroutine：显而易见，使用goroutine，将并发单元的粒度进行细化【并且结合来golang本身的函数式编程的优势】
//goroutine内函数的返回值直接被丢弃，所以goroutine的return作用就是退出该goroutine【资源回收】
//goroutine之间不存在父子关系【因为作为队列被挂载在P之下】，需要依赖关系只能通过chan结构进行管理【依赖库的context】
//值得注意的是，goroutine本身执行同样不存在阻塞机制【也就是同步状态的话，同样需要使用chan来实现。也就是chan的阻塞特性】

//3.chan【利用chan的赋值和传参的形式来形成对并发处理的生成和结果处理的解耦。这一点也是io原语强化并发实现。只是一直没有充足意识到这一点】
//chan是golang在并发设计上通过强化对应io原语在并发中的作用而设计的组件
//将chan实例进行goroutine传递进而实现并发中的系统并发的同步信息（通过阻塞该goroutine）
//也是golang并发哲学中的：不是通过共享内存而通信，而是通过通信（io）来进行共享内存

//chan中出现panic的场景：
//（1）向已经关闭的chan中写数据
//（2）向已经关闭的chan中再次关闭
//so：对chan的goroutine声明中尽量形成单向的声明结构，防止对chan的操作逻辑过度耦合形成panic

//chan中形成阻塞的场景
//（1）对未初始化的chan进行读写操作，该goroutine会永久阻塞
//（2）向缓冲区已满（或者是无缓冲区的chan中已写入数据的chan）中再写入数据，会出现阻塞
//（3）向chan中是空数据（未写入）chan中进行读操作，会阻塞该goroutine

//chan中未阻塞的场景
//（1）向已经关闭的chan中读取数据，会读到对应chan实例类型的零值，从而结合select（往往是接收关闭的done）进行退出【或者该goroutine进行退出】
//（2）向缓冲区未满的chan中（或者空的无缓存的chan中）写入数据，也不会发生阻塞
//（3）向存在数据的chan中进行去读数据，同样不会发生阻塞

//基于上面的三种场景，形成对应结合goroutine和chan的最佳场景【至于chan的读写阻塞只需要把握清楚对应的同步（阻塞）时机即可】
//（1）使用chan首先进行声明类型，并且初始化【所以常见的chan使用都是直接使用make来声明类型的同时实现了初始化】
//（2）goroutine中要使用chan时，尽量设置成单向的，这样逻辑解耦【写操作的goroutine完成逻辑之后defer关闭该chan】
//（3）注意退出机制【传递相应的chan：因为chan是传递参数的形式，所以一定是值传递】

//4.wg【对于固定数目的goroutine统一阻塞并且完成时使用】
//这一个模式实现的次数最多

//5.select【实现扇入的思想：也就是多路复用】
//一直依赖怀疑的还是select的阻塞特性。[实质上只要检查出某个case已经是ready状态，就进行处理，然后就退出了select]【否则一直阻塞】
//nginx的io复用的思路也是一样。【实质上就是读写的ready检查】
//所以for+select模式联合，就能形成服务器持续捕获io状态，从而分发处理。【结合done的chan，以及外部的label和done case的break label进行退出机制】
//需要注意超时机制设置

//6.扇入扇出思想
//简单来说：扇入思想通过select来实现【多路合并复用】【创建更多的生产者来平衡消费者的处理效率】
//扇出就是：go触发更多的goroutine来进行一路的chan的多路chan消费【更多的消费者平衡生产效果过快】

//7.退出机制【done信号处理，实践中还是尽量使用context进行统一处理】
