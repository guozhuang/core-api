package concurrency

//并发模型相关：
//golang的并发设计就是将并发的整个过程正交化【同样和struct设计思想一致（interface变量的底层结构同样正交）】
//强化了io原语在并发上的实践，将并发通信（channel）与并发处理单元(goroutine)正交解耦。
//于是才得出那句并发哲学：golang是通过通信来共享内存

//并发调度模型【MPG】【当前的理解才更加贴切】
//M：系统内核线程【运行过程中不断唤醒或者创建】【M数量比P数量多是正常的，还存在属于go的调度线程以及监控线程】

//P：是对G队列的管理的数据结构【与M一一绑定】【正是通过P这个间接调度结构形成了M与G的调度实现】
//M+P联合形成G的运行环境。P决定是否和M挂载，以及查看本地的G队列是否处理完成，则查找全局的G队列，否则查看别的P下的G
//所以P本身并不会绑定G的执行环境，而是相当于G处理的加载结构，这样才能非常便利地切换M以及G的查找和追加

//G：是执行单元的元数据【入口函数，堆栈，上下文等信息】【G同样也只是数据结构，所以才说4K，可以创建非常多】
//G对象是可复用的，只需要刷新对应的元数据即可【相当于可以做G的元数据的单元池】

//go中存在的特殊的M0和g0
//启动程序时的第一个线程就是M0，会存放整体的全局变量。M0初始化操作（例如import的引入和init的执行）和启动第一个g之后，M0就和其他的M没有区别
//而每一个M都会绑定一个自己的g0。【g0不会指向任何的执行函数，仅仅是用来管理其对应的M的堆栈以及调度使用】

//go程序初始化过程
//（1）分配和检查栈空间
//（2）初始化参数和环境变量【所以此时可以用来设置P的数量】
//（3）当前运行的线程被标记为M0，作为初始化主线程执行
//（4）调用运行时初始化函数runtime.schedinit进行初始化【内存分配器、GC、空闲P列表】
//（5）在M0上调度第一个G，这个G首先执行init，然后就是main函数。【此时M0就和其他的M一样了】

//M、P、G的创建时机：
//初始化之后，使用go关键字来创建并发调用时，有可能创建G，也可能复用之前的G。
//在拿到对应的G之后，会唤醒M执行任务【这里的唤醒也是先查看当前M是否可以获取，否则全局查看，否则进行创建】
//在P获取M之后，进行挂载，然后进行运行。

//抢占调度：核心就是所有的G都能够得到执行，防止一个比较长时间占据的G阻塞了整个系统

//抢占调度的策略：【这里就用到了上面说的监控的M】
//（1）在系统调用前后（就是触发调用：例如io），检查当前的G是否被监控M抢占调度，
//如果是，则M停止当前G执行，进行调度切换
//（2）监控线程M经过一段时间检测感知P运行超过一定时间，则取消P与M的挂载【强制进行切换】
//（3）监控线程M经过一段时间检测感知G运行超过一定时间，设置G被抢占调度标记。【于是又在第一步上系统调用前后的检出】

//于是抢占策略就是为了所有的G都能被执行到

//实际上golang的语言层面的并发设计确实是贯彻的很好，以及MPG和抢占式调度的方式，所以G本身执行顺序是随机的，同样都能被执行到【抢占式调度】
//end
